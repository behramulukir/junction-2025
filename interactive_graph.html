<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EU Regulation Search - financial regulations for banks</title>
    <style>
        :root {
            --background: oklch(0.985 0 0);
            --foreground: oklch(0.145 0 0);
            --primary: #1e50be;
            --primary-hover: #1a45a8;
            --muted-foreground: oklch(0.708 0 0);
            --border: rgba(0, 0, 0, 0.08);
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --radius: 0.75rem;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--background);
            color: var(--foreground);
            padding: 2rem;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            margin-bottom: 2rem;
        }
        
        h1 {
            font-size: 1.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--foreground);
        }
        
        .subtitle {
            color: var(--muted-foreground);
            font-size: 0.875rem;
        }
        
        .graph-container {
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border);
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }
        
        #canvas {
            width: 100%;
            height: 700px;
            cursor: grab;
            position: relative;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .node {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            transition: all 0.2s ease;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
            padding: 0.5rem;
            line-height: 1.2;
            word-wrap: break-word;
            overflow: visible;
        }
        
        .node:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }
        
        .node.dragging {
            opacity: 0.8;
            cursor: grabbing;
            z-index: 1000;
        }
        
        .node.query {
            background: linear-gradient(135deg, #f0f4ff 0%, #e8f0fe 100%);
            color: #1e3a8a;
            border: 3px solid #3b82f6;
            font-weight: 600;
            z-index: 5;
            font-size: 0.7rem;
            padding: 0.85rem;
            line-height: 1.25;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        
        .edge {
            position: absolute;
            height: 2px;
            transform-origin: 0 50%;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }
        
        .tooltip {
            position: fixed;
            background: white;
            border-radius: var(--radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
            padding: 1rem;
            max-width: 320px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tooltip-title {
            font-size: 0.9375rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--foreground);
            line-height: 1.4;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.8125rem;
        }
        
        .tooltip-label {
            color: var(--muted-foreground);
            font-weight: 500;
        }
        
        .tooltip-value {
            color: var(--foreground);
        }
        
        .tooltip-value.highlight {
            color: var(--primary);
            font-weight: 600;
        }
        
        .tooltip-divider {
            margin: 0.75rem 0;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
        }
        
        .tooltip-summary {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
            font-size: 0.8125rem;
            line-height: 1.5;
            color: oklch(0.439 0 0);
            font-style: italic;
        }
        
        .controls {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: white;
            color: var(--foreground);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .legend {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 0.5rem;
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8125rem;
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1.5px solid;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>EU Regulation Search</h1>
            <p class="subtitle">Query: financial regulations for banks</p>
        </header>
        
        <div class="graph-container">
            <div id="canvas"></div>
            
            <div class="controls">
                <button class="btn" onclick="resetView()">Reset View</button>
            </div>
            
            <div class="legend">
                
                <div class="legend-item">
                    <div class="legend-dot" style="background: #fef3c7; border-color: #f59e0b;"></div>
                    <span>Commission</span>
                </div>
            </div>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
    </div>
    
    <script>
        const nodes = [
  {
    "id": "query",
    "label": "financial regulations for banks",
    "type": "query",
    "size": 50.5
  },
  {
    "id": "node_1",
    "label": "Comm Del Reg 2022/1622",
    "fullName": "Commission Delegated Regulation (EU) 2022/1622",
    "originalName": "Regulation (EU) No 575/2013 of the European Parliament and of the Councilof 26 June 2013 on prudenti",
    "type": "Commission",
    "year": "2022",
    "matches": 4,
    "relevance": 0.6791046261787415,
    "summary": "(77) It is further necessary for competent authorities to have knowledge of the level, at least in aggregate terms, of repurchase agreements, securiti...",
    "size": 51,
    "color": "#f59e0b",
    "bgColor": "#fef3c7"
  },
  {
    "id": "node_2",
    "label": "Comm Del Reg 2022/1622",
    "fullName": "Commission Delegated Regulation (EU) 2022/1622",
    "originalName": "Directive 2013/36/EU of the European Parliament and of the Councilof 26 June 2013 on access to the a",
    "type": "Commission",
    "year": "2022",
    "matches": 3,
    "relevance": 0.6571747660636902,
    "summary": "(99) In order to allow for technical standards to be developed so that institutions that are part of a financial conglomerate apply the appropriate ca...",
    "size": 47,
    "color": "#f59e0b",
    "bgColor": "#fef3c7"
  },
  {
    "id": "node_3",
    "label": "Comm Del Reg 2022/1622",
    "fullName": "Commission Delegated Regulation (EU) 2022/1622",
    "originalName": "Commission Delegated Regulation (EU) 2016/1608",
    "type": "Commission",
    "year": "2022",
    "matches": 1,
    "relevance": 0.6550465822219849,
    "summary": "(4) In order to reflect current developments in the global banking system and minimise the administrative burden for institutions, it is important to ...",
    "size": 39,
    "color": "#f59e0b",
    "bgColor": "#fef3c7"
  },
  {
    "id": "node_4",
    "label": "Comm Del Reg 2022/1622",
    "fullName": "Commission Delegated Regulation (EU) 2022/1622",
    "originalName": "Commission Delegated Regulation (EU) 2021/2154",
    "type": "Commission",
    "year": "2022",
    "matches": 1,
    "relevance": 0.6527000665664673,
    "summary": "(12) This Regulation is based on the draft regulatory technical standards submitted to the Commission by the EBA after having consulted the European S...",
    "size": 39,
    "color": "#f59e0b",
    "bgColor": "#fef3c7"
  },
  {
    "id": "node_5",
    "label": "Comm Del Reg 2022/1622",
    "fullName": "Commission Delegated Regulation (EU) 2022/1622",
    "originalName": "Commission Delegated Regulation (EU) 2022/1622",
    "type": "Commission",
    "year": "2022",
    "matches": 1,
    "relevance": 0.6509671211242676,
    "summary": "(3) This Regulation is based on the draft regulatory technical standards submitted to the Commission by the European Banking Authority.\n(4) The Europe...",
    "size": 39,
    "color": "#f59e0b",
    "bgColor": "#fef3c7"
  }
];
        const edges = [
  {
    "from": "query",
    "to": "node_1",
    "weight": 0.6791046261787415,
    "color": "rgba(245, 158, 11, 0.35)",
    "matches": 4
  },
  {
    "from": "query",
    "to": "node_2",
    "weight": 0.6571747660636902,
    "color": "rgba(245, 158, 11, 0.35)",
    "matches": 3
  },
  {
    "from": "query",
    "to": "node_3",
    "weight": 0.6550465822219849,
    "color": "rgba(245, 158, 11, 0.35)",
    "matches": 1
  },
  {
    "from": "query",
    "to": "node_4",
    "weight": 0.6527000665664673,
    "color": "rgba(245, 158, 11, 0.35)",
    "matches": 1
  },
  {
    "from": "query",
    "to": "node_5",
    "weight": 0.6509671211242676,
    "color": "rgba(245, 158, 11, 0.35)",
    "matches": 1
  }
];
        
        const canvas = document.getElementById('canvas');
        const tooltip = document.getElementById('tooltip');
        
        let isDragging = false;
        let draggedNode = null;
        let offset = { x: 0, y: 0 };
        let connectedNodes = new Set();
        
        // Physics simulation variables
        let animationId = null;
        const damping = 0.88; // Damping for smooth movement
        const linkStrength = 0.03; // Strength of connection between nodes
        const linkDistance = 150; // Desired distance between connected nodes
        
        // Store original positions and velocities
        nodes.forEach(node => {
            node.vx = 0;
            node.vy = 0;
            node.originalX = 0;
            node.originalY = 0;
            node.isDragged = false;
        });
        
        // Initialize node positions (circular layout around center)
        function initializePositions() {
            const centerX = canvas.offsetWidth / 2;
            const centerY = canvas.offsetHeight / 2;
            const radius = Math.min(centerX, centerY) * 0.6;
            
            nodes.forEach((node, i) => {
                if (node.type === 'query') {
                    node.x = centerX;
                    node.y = centerY;
                    node.originalX = centerX;
                    node.originalY = centerY;
                } else {
                    const angle = (i / (nodes.length - 1)) * 2 * Math.PI;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                    node.originalX = node.x;
                    node.originalY = node.y;
                }
                node.vx = 0;
                node.vy = 0;
            });
        }
        
        // Render edges
        function renderEdges() {
            const existingEdges = canvas.querySelectorAll('.edge');
            existingEdges.forEach(e => e.remove());
            
            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                
                if (!fromNode || !toNode) return;
                
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                const edgeEl = document.createElement('div');
                edgeEl.className = 'edge';
                edgeEl.style.width = length + 'px';
                edgeEl.style.left = fromNode.x + 'px';
                edgeEl.style.top = fromNode.y + 'px';
                edgeEl.style.transform = `rotate(${angle}deg)`;
                edgeEl.style.background = edge.color;
                edgeEl.style.opacity = '0.5';
                
                canvas.appendChild(edgeEl);
            });
        }
        
        // Render nodes
        function renderNodes() {
            const existingNodes = canvas.querySelectorAll('.node');
            existingNodes.forEach(n => n.remove());
            
            nodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node' + (node.type === 'query' ? ' query' : '');
                nodeEl.style.width = node.size * 2 + 'px';
                nodeEl.style.height = node.size * 2 + 'px';
                nodeEl.style.left = (node.x - node.size) + 'px';
                nodeEl.style.top = (node.y - node.size) + 'px';
                
                if (node.type !== 'query') {
                    nodeEl.style.background = node.bgColor;
                    nodeEl.style.border = '2px solid ' + node.color;
                    nodeEl.style.color = 'oklch(0.145 0 0)';
                    nodeEl.style.padding = '0.5rem';
                    nodeEl.style.fontSize = '0.7rem';
                    // Display full label - the node is sized to fit it
                    nodeEl.textContent = node.label;
                } else {
                    // Query node - show full text with wrapping
                    nodeEl.textContent = node.label;
                    nodeEl.style.whiteSpace = 'normal';
                    nodeEl.style.wordBreak = 'break-word';
                }
                
                nodeEl.dataset.nodeId = node.id;
                
                // Tooltip on hover
                nodeEl.addEventListener('mouseenter', (e) => {
                    if (node.type === 'query') {
                        showTooltip(e, `
                            <div class="tooltip-title">${node.label}</div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Total Results:</span>
                                <span class="tooltip-value">10</span>
                            </div>
                        `);
                    } else {
                        showTooltip(e, `
                            <div class="tooltip-title">${node.fullName}</div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Type:</span>
                                <span class="tooltip-value">${node.type}</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Year:</span>
                                <span class="tooltip-value">${node.year}</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Matches:</span>
                                <span class="tooltip-value">${node.matches}</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Relevance:</span>
                                <span class="tooltip-value highlight">${(node.relevance * 100).toFixed(1)}%</span>
                            </div>
                            ${node.summary ? `<div class="tooltip-summary">${node.summary}</div>` : ''}
                        `);
                    }
                });
                
                nodeEl.addEventListener('mouseleave', hideTooltip);
                
                // Dragging - allow all nodes to be dragged
                nodeEl.addEventListener('mousedown', (e) => {
                    const canvasRect = canvas.getBoundingClientRect();
                    isDragging = true;
                    draggedNode = node;
                    node.isDragged = true;
                    node.vx = 0;
                    node.vy = 0;
                    nodeEl.classList.add('dragging');
                    offset = {
                        x: e.clientX - canvasRect.left - node.x,
                        y: e.clientY - canvasRect.top - node.y
                    };
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Start physics simulation
                    startPhysics();
                });
                
                canvas.appendChild(nodeEl);
            });
        }
        
        function showTooltip(e, content) {
            tooltip.innerHTML = content;
            tooltip.style.left = e.pageX + 2 + 'px';
            tooltip.style.top = e.pageY + 2 + 'px';
            tooltip.classList.add('visible');
        }
        
        function hideTooltip() {
            tooltip.classList.remove('visible');
        }
        
        // Get connected nodes for a given node
        function getConnectedNodes(node) {
            const connected = new Set();
            edges.forEach(edge => {
                if (edge.from === node.id) {
                    const connectedNode = nodes.find(n => n.id === edge.to);
                    if (connectedNode) connected.add(connectedNode);
                }
                if (edge.to === node.id) {
                    const connectedNode = nodes.find(n => n.id === edge.from);
                    if (connectedNode) connected.add(connectedNode);
                }
            });
            return connected;
        }
        
        // Physics simulation - nodes follow dragged nodes
        function applyPhysics() {
            let hasMovement = false;
            
            // Apply link forces between connected nodes
            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                
                if (!fromNode || !toNode) return;
                
                // Calculate distance and direction
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance === 0) return;
                
                // Apply spring force to maintain desired distance
                const force = (distance - linkDistance) * linkStrength;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                
                // Don't apply force to dragged node
                if (!fromNode.isDragged) {
                    fromNode.vx += fx;
                    fromNode.vy += fy;
                }
                if (!toNode.isDragged) {
                    toNode.vx -= fx;
                    toNode.vy -= fy;
                }
            });
            
            // Update positions based on velocities
            nodes.forEach(node => {
                if (node.isDragged) return; // Skip dragged node
                
                // Apply damping
                node.vx *= damping;
                node.vy *= damping;
                
                // Update position
                node.x += node.vx;
                node.y += node.vy;
                
                // Keep nodes within canvas bounds
                const margin = node.size || 20;
                node.x = Math.max(margin, Math.min(canvas.offsetWidth - margin, node.x));
                node.y = Math.max(margin, Math.min(canvas.offsetHeight - margin, node.y));
                
                // Check if still moving
                if (Math.abs(node.vx) > 0.05 || Math.abs(node.vy) > 0.05) {
                    hasMovement = true;
                }
            });
            
            render();
            
            // Continue animation if there's movement or dragging
            if (hasMovement || isDragging) {
                animationId = requestAnimationFrame(applyPhysics);
            } else {
                animationId = null;
            }
        }
        
        // Start physics loop
        function startPhysics() {
            if (!animationId) {
                animationId = requestAnimationFrame(applyPhysics);
            }
        }
        
        // Mouse move handler
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedNode) {
                const canvasRect = canvas.getBoundingClientRect();
                const newX = e.clientX - canvasRect.left - offset.x;
                const newY = e.clientY - canvasRect.top - offset.y;
                
                // Keep node within bounds
                const margin = draggedNode.size || 20;
                draggedNode.x = Math.max(margin, Math.min(canvas.offsetWidth - margin, newX));
                draggedNode.y = Math.max(margin, Math.min(canvas.offsetHeight - margin, newY));
                
                // Render immediately for smooth dragging
                render();
            }
            
            if (tooltip.classList.contains('visible')) {
                tooltip.style.left = e.pageX + 2 + 'px';
                tooltip.style.top = e.pageY + 2 + 'px';
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging && draggedNode) {
                draggedNode.isDragged = false;
                const nodeEl = canvas.querySelector(`[data-node-id="${draggedNode.id}"]`);
                if (nodeEl) nodeEl.classList.remove('dragging');
                draggedNode = null;
                
                // Continue physics for a bit to settle connected nodes
                startPhysics();
            }
            isDragging = false;
        });
        
        function render() {
            renderEdges();
            renderNodes();
        }
        
        function resetView() {
            initializePositions();
            startPhysics();
        }
        
        // Initialize
        initializePositions();
        render();
        startPhysics();
        
        // Redraw on window resize
        window.addEventListener('resize', () => {
            resetView();
        });
    </script>
</body>
</html>